# DS-019: Synthetic Evaluation System (Formal Grammars)

**Version**: 1.0  
**Status**: Draft  
**Author**: BSP Team  
**Date**: 2026-01-15

---

## 1. Overview

The Synthetic Evaluation System provides a controlled environment to verify BSP's ability to learn **transitive closures** and **long-range dependencies**. Unlike natural language, where truth is ambiguous, this system uses a deterministic generative grammar where the "ground truth" (the final state) is known and fixed.

## 2. Theoretical Model: The "Convergent Grammar"

We define a grammar $G = (V_N, V_T, P, S)$ where:
- $V_T$: The set of **Terminals** (Targets). Size $\le 100$. (e.g., "TARGET_01", ... "TARGET_99").
- $V_N$: The set of **Non-Terminals** (Intermediate states). Size variable (e.g., 1,000 - 10,000).
- $P$: Production rules of the form $A \rightarrow B$ or $A \rightarrow t$ (where $t \in V_T$).

### 2.1 Properties
1.  **Convergence**: Every non-terminal $n \in V_N$ eventually leads to exactly one terminal $t \in V_T$.
2.  **Variable Length**: The path from a start node to a terminal can vary (e.g., 2 steps vs 20 steps).
3.  **Transitive Closure**: The system must learn that if $A \rightarrow B$ and $B \rightarrow C$ and $C \rightarrow T$, then $A \implies T$.

### 2.2 Task Definition
Given a prefix of a sequence generated by $G$, predict the **final terminal** $T$.

*   **Training**: Sequences of full derivations: $S_1 \rightarrow S_2 \rightarrow \dots \rightarrow T$.
*   **Evaluation**:
    *   Input: $S_1$ (or $S_1 \rightarrow S_2$)
    *   Target: $T$
    *   The system must "skip" the intermediate steps in its prediction or successfully navigate the chain to $T$.

## 3. Implementation Plan

### 3.1 Directory Structure (`evals/synthetic/`)
*   `grammar.mjs`: Defines the rules and state machine generation.
*   `generate.mjs`: Produces training corpora and test sets.
*   `evaluate.mjs`: Runs the engine and measures "Final Token Accuracy".

### 3.2 Evaluation Metrics
*   **Convergence Accuracy**: % of times the system predicts the correct final $T$ given an early state $S_{start}$.
*   **Path Efficiency**: Can the system predict $T$ immediately, or does it need to generate the intermediate steps?
*   **Stability**: Does prediction accuracy degrade as path length increases?

## 4. Grammar Configuration (Default)

```json
{
  "numTerminals": 100,
  "numIntermediates": 1000,
  "minPathLength": 3,
  "maxPathLength": 15,
  "branchingFactor": 2  // Number of possible paths to the same target
}
```
